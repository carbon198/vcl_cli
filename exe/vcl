#!/usr/bin/ruby

require "bundler/setup"
require "vcl"

class VclAdmin < Thor
  desc "purge_all", "Purge all content from a service. Options: --service"
  option :service
  def purge_all
    parsed_id = VCL::Utils.parse_directory

    id = VCL::Utils.parse_directory

    abort "could not parse service id from directory" unless (id || options[:service])

    VCL::Fetcher.api_request(:post, "/service/#{id}/purge_all")

    say("Purge all on #{id} completed.")
  end

  desc "open DOMAIN", "Find the service ID for a domain and open the Fastly app."
  def open(domain)
    id = VCL::Fetcher.domain_to_service_id(domain)

    Launchy.open(VCL::FASTLY_APP + VCL::TANGO_PATH + id)
  end

  desc "download VCL_NAME=all", "Download VCLs. Options: --service, --version"
  option :service
  option :version
  def download(vcl_name=false)
    parsed_id = VCL::Utils.parse_directory

    if options[:service]
      abort "Already in a service directory, go up one level in order to specify"\
            "service id with --service." if parsed_id
      id = options[:service]
      parsed = false
    else
      abort "Could not parse service id from directory. Specify service id with "\
            "--service option or use from within service directory." unless parsed_id
      id = parsed_id
      parsed = true
    end

    service = VCL::Fetcher.api_request(:get, "/service/#{id}/details")

    version = VCL::Fetcher.get_active_version(id) unless options[:version]
    version ||= options[:version]

    vcl = VCL::Fetcher.get_vcl(id, version)

    folder_name = parsed ? "./" : "#{service["name"]} - #{service["id"]}/"
    Dir.mkdir(folder_name) unless (File.directory?(folder_name) || parsed)

    if vcl

    vcl.each do |v,k|
        next if (vcl_name && vcl_name != v["name"])

        filename = "#{folder_name}#{v["name"]}.vcl"

        if File.exist?(filename)
          unless yes?("Are you sure you want to overwrite #{filename}")
            say("Skipping #{filename}")
            next
          end
        end

        File.open(filename, 'w+') {|f| f.write(v["content"]) }

        say("VCL content for version #{version} written to #{filename}")
      end
    else
      say("No VCLs on this service, however a folder has been created. Create VCLs in this folder and upload.")
    end
  end

  desc "waf", "Download WAF VCLs"
  def waf
    parsed_id = VCL::Utils.parse_directory

    if options[:service]
      abort "Already in a service directory, go up one level in order to specify"\
            "service id with --service." if parsed_id
      id = options[:service]
      parsed = false
    else
      abort "Could not parse service id from directory. Specify service id with "\
            "--service option or use from within service directory." unless parsed_id
      id = parsed_id
      parsed = true
    end

    service = VCL::Fetcher.api_request(:get, "/service/#{id}/details")

    customer_id = service["customer_id"]

    VCL::Fetcher.assume_account_owner(customer_id)

    waf = VCL::Fetcher.api_request(:get, "/service/#{id}/wafs/4o0eNn2qV1zmqfosNx4CwQ/ruleset", :endpoint => :app)
    
    VCL::Fetcher.unassume

    folder_name = parsed ? "./" : "#{service["name"]} - #{service["id"]}/"
    Dir.mkdir(folder_name) unless (File.directory?(folder_name) || parsed)

    if waf
      filename = "#{folder_name}ruleset.waf"

      if File.exist?(filename)
        unless yes?("Are you sure you want to overwrite #{filename}")
          say("Skipping #{filename}")
          return
        end
      end

      File.open(filename, 'w+') {|f| f.write(waf["data"]["attributes"]["vcl"]) }

      say("WAF VCL content written to #{filename}")
    else
      say("WAF is not enabled on this service.")
    end
  end

  desc "diff SERVICE_ID VERSION1 VERSION2", "Diff two versions on the same service. Options: --generated"
  option :generated
  def diff(id,v1,v2)
    v1_vcls = VCL::Fetcher.get_vcl(id, v1, options[:generated])
    v2_vcls = VCL::Fetcher.get_vcl(id, v2, options[:generated])

    if options[:generated]
      say(VCL::Utils.diff_generated(v1_vcls,v2_vcls))
    else
      say(VCL::Utils.diff_versions(v1_vcls,v2_vcls))
    end
  end

  desc "diff_services SERVICE_ID1 VERSION1 SERVICE_ID2 VERSION2", "Diff versions on two different services. Options: --generated"
  option :generated
  def diff_services(id1,v1,id2,v2)
    v1_vcls = VCL::Fetcher.get_vcl(id1, v1, options[:generated])
    v2_vcls = VCL::Fetcher.get_vcl(id2, v2, options[:generated])

    unless (v1_vcls && v2_vcls)
      say("There is no custom VCL on #{v1_vcls ? id2 : id1}, use the --generated flag if you wanted to diff the generated VCL.")
      abort
    end

    if options[:generated]
      say(VCL::Utils.diff_generated(v1_vcls,v2_vcls))
    else
      say(VCL::Utils.diff_versions(v1_vcls,v2_vcls))
    end
  end

  desc "diff_local", "Diff VCL on Fastly with local VCL. Options: --version"
  option :version
  def diff_local
    id = VCL::Utils.parse_directory

    abort "could not parse service id from directory" unless id

    version = VCL::Fetcher.get_active_version(id) unless options[:version]
    version ||= options[:version]

    v1_vcls = VCL::Fetcher.get_vcl(id, version)
    v1_vcls ||= []

    v2_vcls = []

    Dir.foreach(Dir.pwd) do |p|
      next unless File.file?(p)
      next unless p =~ /\.vcl$/

      v2_vcls << {
        "name" => p.chomp(".vcl"),
        "content" => File.read(p)
      }
    end

    say(VCL::Utils.diff_versions(v1_vcls,v2_vcls))
  end

  desc "upload", "Uploads VCL in the current directory to the service. Options: --version"
  option :version
  def upload
    id = VCL::Utils.parse_directory

    abort "could not parse service id from directory" unless id

    vcls = {}

    Dir.foreach(Dir.pwd) do |p|
      next unless File.file?(p)
      next unless p =~ /\.vcl$/
      vcls[p.chomp(".vcl")] = {"content" => File.read(p), "name" => p.chomp(".vcl")}
    end

    writable_version = VCL::Fetcher.get_writable_version(id) unless options[:version]
    writable_version ||= options[:version].to_i
    active_version = VCL::Fetcher.get_active_version(id);

    old_vcls = VCL::Fetcher.get_vcl(id, active_version)

    main_found = false

    old_vcls ||= {}
    old_vcls.each do |v|
      next unless vcls.has_key? v["name"]
      diff = VCL::Utils.get_diff(v["content"], vcls[v["name"]]["content"])

      vcls[v["name"]]["matched"] = true
      vcls[v["name"]]["new"] = false
      main_found = vcls[v["name"]]["main"] = v["main"] == true ? true : false

      next if diff.length < 2

      say(diff)
    end

    vcls.delete_if do |k,v|
      if (v["matched"] == true)
        false
      elsif yes?("VCL #{v["name"]} does not currently exist on the service, would you like to create it?")
        v["new"] = true
        if !main_found
          v["main"] = true 
          main_found = true
        end
        say(VCL::Utils.get_diff("", v["content"]))
        false
      else 
        say("Not uploading #{v["name"]}")
        true
      end
    end

    abort unless yes?("Given the above diff, are you sure you want to upload your changes?")

    vcls.each do |k,v|
      VCL::Fetcher.upload_vcl(id, writable_version, v["content"], v["name"], v["main"], v["new"])

      say("#{v["name"]} uploaded to #{id}")
    end

    validation = VCL::Fetcher.api_request(:get, "/service/#{id}/version/#{writable_version}/validate")

    abort "Compiler reported the following error with the generated VCL: #{validation["msg"]}" if validation["status"] == "error"

    say("VCL(s) have been uploaded to version #{writable_version} and validated.")
  end

  desc "activate", "Activates a service version. Options: --service, --version"
  option :service
  option :version
  def activate
    id = VCL::Utils.parse_directory unless options[:service]
    id ||= options[:service]

    abort "could not parse service id from directory" unless id

    writable_version = VCL::Fetcher.get_writable_version(id) unless options[:version]
    writable_version ||= options[:version].to_i

    VCL::Fetcher.api_request(:put, "/service/#{id}/version/#{writable_version}/activate")

    say("Version #{writable_version} on #{id} activated.")
  end

  desc "services CUSTOMER_ID", "Lists services for a customer."
  def services(customer_id)
    services = VCL::Fetcher.api_request(:get, "/customer/#{customer_id}/service_ids")

    abort "Customer has no services." if services.length == 0

    services.each do |s|
      service = VCL::Fetcher.api_request(:get, "/service/#{s}/details")
      say("#{service["name"]} - #{service["id"]}")
    end
  end

  desc "clone SERVICE_ID TARGET_SERVICE_ID", "Clone a service version to another service."
  option :version
  def clone(id,target_id)
    version = VCL::Fetcher.get_active_version(id) unless options[:version]
    version ||= options[:version]

    result = VCL::Fetcher.api_request(:put, "/service/#{id}/version/#{version}/copy/to/#{target_id}")

    say("#{id} version #{version} copied to #{target_id} version #{result["number"]}")
  end

  desc "move SERVICE_ID TARGET_CUSTOMER", "Move a service to a new customer"
  def move(service_id, customer_id)
    pass = self.ask("This API endpoint requires your app.fastly.com password: ", :echo => false)

    resp = VCL::Fetcher.api_request(:put, "/service/#{service_id}/change_customer/#{customer_id}?password=#{url_encode(pass)}", :endpoint => :app)

    say("\nService successfully moved to #{customer_id}")
  end

  desc "create_service CUSTOMER_ID SERVICE_NAME DOMAIN ORIGIN", "Create a blank service for a customer."
  def create_service(id, name, domain, origin)
    VCL::Fetcher.assume_account_owner(id)

    service = VCL::Fetcher.api_request(:post, "/quickstart", { :endpoint => :app, body: "name=#{URI.escape(name)}&address=#{URI.escape(origin)}&port=80&domain=#{URI.escape(domain)}"})

    VCL::Fetcher.unassume

    say("Service #{service["service"]["versions"][0]["service_id"]} has been created. If you are already on the configure tab you may need to refresh.")
  end

  desc "dictionary ACTION DICTIONARY_NAME=none KEY=none VALUE=none", "Manipulate edge dictionaries. Actions: create, delete, list, add, update, remove, list_items, bulk_add. Options: --service --version"
  option :service
  option :version
  def dictionary(action, name=false, key=false, value=false)
    id = VCL::Utils.parse_directory unless options[:service]
    id ||= options[:service]

    abort "Could not parse service id from directory. Specify service id with --service or use from within service directory." unless id

    version = VCL::Fetcher.get_writable_version(id) unless options[:version]
    version ||= options[:version]

    case action
    when "create"
      abort "Must specify name for dictionary" unless name
      VCL::Fetcher.api_request(:post, "/service/#{id}/version/#{version}/dictionary", body: "name=#{URI.escape(name)}")

      say("Dictionary #{name} created.")
    when "delete"
      abort "Must specify name for dictionary" unless name
      VCL::Fetcher.api_request(:delete, "/service/#{id}/version/#{version}/dictionary/#{name}")

      say("Dictionary #{name} deleted.")
    when "list"
      resp = VCL::Fetcher.api_request(:get, "/service/#{id}/version/#{version}/dictionary")

      say("No dictionaries on service in this version.") unless resp.length > 0

      resp.each do |d|
        puts "#{d["id"]} - #{d["name"]}"
      end
    when "add"
      abort "Must specify name for dictionary" unless name
      abort "Must specify key and value for dictionary item" unless (key && value)
      dict = VCL::Fetcher.api_request(:get, "/service/#{id}/version/#{version}/dictionary/#{name}")
      VCL::Fetcher.api_request(:post, "/service/#{id}/dictionary/#{dict["id"]}/item", body: "item_key=#{key}&item_value=#{value}")

      say("Dictionary item #{key} created with value #{value}.")
    when "update"
      abort "Must specify name for dictionary" unless name
      abort "Must specify key and value for dictionary item" unless (key && value)
      dict = VCL::Fetcher.api_request(:get, "/service/#{id}/version/#{version}/dictionary/#{name}")
      VCL::Fetcher.api_request(:put, "/service/#{id}/dictionary/#{dict["id"]}/item/#{key}", body: "item_value=#{value}")   

      say("Dictionary item #{key} set to #{value}.")   
    when "remove"
      abort "Must specify name for dictionary" unless name
      abort "Must specify key for dictionary item" unless key
      dict = VCL::Fetcher.api_request(:get, "/service/#{id}/version/#{version}/dictionary/#{name}")
      VCL::Fetcher.api_request(:delete, "/service/#{id}/dictionary/#{dict["id"]}/item/#{key}")

      say("Item #{key} removed from dictionary #{name}.")
    when "list_items"
      abort "Must specify name for dictionary" unless name
      dict = VCL::Fetcher.api_request(:get, "/service/#{id}/version/#{version}/dictionary/#{name}")
      resp = VCL::Fetcher.api_request(:get, "/service/#{id}/dictionary/#{dict["id"]}/items")

      say("No items in dictionary.") unless resp.length > 0
      resp.each do |i|
        puts "#{i["item_key"]} : #{i["item_value"]}"
      end
    when "bulk_add"
      abort "Must specify name for dictionary" unless name
      dict = VCL::Fetcher.api_request(:get, "/service/#{id}/version/#{version}/dictionary/#{name}")

      items = JSON.parse(key)
      items.each do |k,v|
        VCL::Fetcher.api_request(:post, "/service/#{id}/dictionary/#{dict["id"]}/item", body: "item_key=#{k}&item_value=#{v}")

        say("#{k} added to #{name} with value #{v}")
      end
    end
  end

  desc "login", "Logs into the app. Required before doing anything else."
  def login
    if VCL::Token
      abort unless yes?("You already have an access token, are you sure you want to authenticate again?")
    end

    user = self.ask("Username: ")
    pass = self.ask("Password: ", :echo => false)
    resp = VCL::Fetcher.api_request(:post, "/login", { :endpoint => :app, body: "user=#{url_encode(user)}&password=#{url_encode(pass)}"})

    if resp["needs_two_factor_auth"]
      two_factor = true

      say("\nTwo factor auth enabled on account, second factor needed.")
      code = ask('Please enter verification code:', echo: false)

      resp = VCL::Fetcher.api_request(:post, "/two_factor_auth/verify", {force_session: true, :endpoint => :app, body: "token=#{code}"} )
    else
      say("\nTwo factor auth is NOT enabled. You should go do that immediately.")
    end

    File.open(VCL::COOKIE_JAR , 'w+') {|f| f.write(JSON.dump(VCL::Cookies)) }
    File.chmod(0600, VCL::COOKIE_JAR)

    say("Login successful!")
    say("Creating root scoped token...")

    headers = {}
    headers["Fastly-OTP"] = code

    VCL::Fetcher.api_request(:post, "/sudo", {force_session: true, :endpoint => :api, body: "user=#{url_encode(user)}&password=#{url_encode(pass)}", headers: headers})
    resp = VCL::Fetcher.api_request(:post, "/tokens", {force_session: true, :endpoint => :api, body: "name=vcl_cli_token&scope=root&user=#{url_encode(user)}&password=#{url_encode(pass)}", headers: headers})

    token = resp["access_token"]
    token_id = resp["id"]

    say("\n#{token_id} created.")

    File.open(VCL::TOKEN_FILE , 'w+') {|f| f.write(token) }
    File.chmod(0600, VCL::TOKEN_FILE)

    resp = VCL::Fetcher.api_request(:get, "/tokens", { headers: {"Fastly-Key" => token}})
    abort unless resp.count > 0

    resp.each do |t|
      next unless (t["name"] == "vcl_cli_token" && t["id"] != token_id)

      if yes?("There was already a token created with the name vcl_cli_token. To avoid creating multiple tokens, should it be deleted?")
        VCL::Fetcher.api_request(:delete, "/tokens/#{t["id"]}", {headers: {"Fastly-Key" => token}, expected_response: 204})
        say("Token with id #{t["id"]} deleted.")
      end
    end
  end

  desc "version", "Displays version of the VCL gem."
  def version
    say("VCL gem version is #{VCL::VERSION}")
  end
end

VclAdmin.start(ARGV)
